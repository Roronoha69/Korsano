{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar _require = require('./HttpClient'),\n    HttpClient = _require.HttpClient,\n    HttpClientResponse = _require.HttpClientResponse;\n\nvar defaultHttpAgent = new http.Agent({\n  keepAlive: true\n});\nvar defaultHttpsAgent = new https.Agent({\n  keepAlive: true\n});\n/**\n * HTTP client which uses the Node `http` and `https` packages to issue\n * requests.`\n */\n\nvar NodeHttpClient = /*#__PURE__*/function (_HttpClient) {\n  _inherits(NodeHttpClient, _HttpClient);\n\n  var _super = _createSuper(NodeHttpClient);\n\n  function NodeHttpClient(agent) {\n    var _this;\n\n    _classCallCheck(this, NodeHttpClient);\n\n    _this = _super.call(this);\n    _this._agent = agent;\n    return _this;\n  }\n  /** @override. */\n\n\n  _createClass(NodeHttpClient, [{\n    key: \"getClientName\",\n    value: function getClientName() {\n      return 'node';\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n      var isInsecureConnection = protocol === 'http';\n      var agent = this._agent;\n\n      if (!agent) {\n        agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;\n      }\n\n      var requestPromise = new Promise(function (resolve, reject) {\n        var req = (isInsecureConnection ? http : https).request({\n          host: host,\n          port: port,\n          path: path,\n          method: method,\n          agent: agent,\n          headers: headers,\n          ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5'\n        });\n        req.setTimeout(timeout, function () {\n          req.destroy(HttpClient.makeTimeoutError());\n        });\n        req.on('response', function (res) {\n          resolve(new NodeHttpClientResponse(res));\n        });\n        req.on('error', function (error) {\n          reject(error);\n        });\n        req.once('socket', function (socket) {\n          if (socket.connecting) {\n            socket.once(isInsecureConnection ? 'connect' : 'secureConnect', function () {\n              // Send payload; we're safe:\n              req.write(requestData);\n              req.end();\n            });\n          } else {\n            // we're already connected\n            req.write(requestData);\n            req.end();\n          }\n        });\n      });\n      return requestPromise;\n    }\n  }]);\n\n  return NodeHttpClient;\n}(HttpClient);\n\nvar NodeHttpClientResponse = /*#__PURE__*/function (_HttpClientResponse) {\n  _inherits(NodeHttpClientResponse, _HttpClientResponse);\n\n  var _super2 = _createSuper(NodeHttpClientResponse);\n\n  function NodeHttpClientResponse(res) {\n    var _this2;\n\n    _classCallCheck(this, NodeHttpClientResponse);\n\n    _this2 = _super2.call(this, res.statusCode, res.headers || {});\n    _this2._res = res;\n    return _this2;\n  }\n\n  _createClass(NodeHttpClientResponse, [{\n    key: \"getRawResponse\",\n    value: function getRawResponse() {\n      return this._res;\n    }\n  }, {\n    key: \"toStream\",\n    value: function toStream(streamCompleteCallback) {\n      // The raw response is itself the stream, so we just return that. To be\n      // backwards compatible, we should invoke the streamCompleteCallback only\n      // once the stream has been fully consumed.\n      this._res.once('end', function () {\n        return streamCompleteCallback();\n      });\n\n      return this._res;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        var response = '';\n\n        _this3._res.setEncoding('utf8');\n\n        _this3._res.on('data', function (chunk) {\n          response += chunk;\n        });\n\n        _this3._res.once('end', function () {\n          try {\n            resolve(JSON.parse(response));\n          } catch (e) {\n            reject(e);\n          }\n        });\n      });\n    }\n  }]);\n\n  return NodeHttpClientResponse;\n}(HttpClientResponse);\n\nmodule.exports = {\n  NodeHttpClient: NodeHttpClient,\n  NodeHttpClientResponse: NodeHttpClientResponse\n};","map":{"version":3,"names":["http","require","https","HttpClient","HttpClientResponse","defaultHttpAgent","Agent","keepAlive","defaultHttpsAgent","NodeHttpClient","agent","_agent","host","port","path","method","headers","requestData","protocol","timeout","isInsecureConnection","requestPromise","Promise","resolve","reject","req","request","ciphers","setTimeout","destroy","makeTimeoutError","on","res","NodeHttpClientResponse","error","once","socket","connecting","write","end","statusCode","_res","streamCompleteCallback","response","setEncoding","chunk","JSON","parse","e","module","exports"],"sources":["/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/stripe/lib/net/NodeHttpClient.js"],"sourcesContent":["'use strict';\n\nconst http = require('http');\nconst https = require('https');\n\nconst {HttpClient, HttpClientResponse} = require('./HttpClient');\n\nconst defaultHttpAgent = new http.Agent({keepAlive: true});\nconst defaultHttpsAgent = new https.Agent({keepAlive: true});\n\n/**\n * HTTP client which uses the Node `http` and `https` packages to issue\n * requests.`\n */\nclass NodeHttpClient extends HttpClient {\n  constructor(agent) {\n    super();\n    this._agent = agent;\n  }\n\n  /** @override. */\n  getClientName() {\n    return 'node';\n  }\n\n  makeRequest(\n    host,\n    port,\n    path,\n    method,\n    headers,\n    requestData,\n    protocol,\n    timeout\n  ) {\n    const isInsecureConnection = protocol === 'http';\n\n    let agent = this._agent;\n    if (!agent) {\n      agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;\n    }\n\n    const requestPromise = new Promise((resolve, reject) => {\n      const req = (isInsecureConnection ? http : https).request({\n        host: host,\n        port: port,\n        path,\n        method,\n        agent,\n        headers,\n        ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5',\n      });\n\n      req.setTimeout(timeout, () => {\n        req.destroy(HttpClient.makeTimeoutError());\n      });\n\n      req.on('response', (res) => {\n        resolve(new NodeHttpClientResponse(res));\n      });\n\n      req.on('error', (error) => {\n        reject(error);\n      });\n\n      req.once('socket', (socket) => {\n        if (socket.connecting) {\n          socket.once(\n            isInsecureConnection ? 'connect' : 'secureConnect',\n            () => {\n              // Send payload; we're safe:\n              req.write(requestData);\n              req.end();\n            }\n          );\n        } else {\n          // we're already connected\n          req.write(requestData);\n          req.end();\n        }\n      });\n    });\n\n    return requestPromise;\n  }\n}\n\nclass NodeHttpClientResponse extends HttpClientResponse {\n  constructor(res) {\n    super(res.statusCode, res.headers || {});\n    this._res = res;\n  }\n\n  getRawResponse() {\n    return this._res;\n  }\n\n  toStream(streamCompleteCallback) {\n    // The raw response is itself the stream, so we just return that. To be\n    // backwards compatible, we should invoke the streamCompleteCallback only\n    // once the stream has been fully consumed.\n    this._res.once('end', () => streamCompleteCallback());\n    return this._res;\n  }\n\n  toJSON() {\n    return new Promise((resolve, reject) => {\n      let response = '';\n\n      this._res.setEncoding('utf8');\n      this._res.on('data', (chunk) => {\n        response += chunk;\n      });\n      this._res.once('end', () => {\n        try {\n          resolve(JSON.parse(response));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = {NodeHttpClient, NodeHttpClientResponse};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}