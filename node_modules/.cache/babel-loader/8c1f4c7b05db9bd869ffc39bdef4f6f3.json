{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _require = require('./HttpClient'),\n    HttpClient = _require.HttpClient,\n    HttpClientResponse = _require.HttpClientResponse;\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\n\n\nvar FetchHttpClient = /*#__PURE__*/function (_HttpClient) {\n  _inherits(FetchHttpClient, _HttpClient);\n\n  var _super = _createSuper(FetchHttpClient);\n\n  function FetchHttpClient(fetchFn) {\n    var _this;\n\n    _classCallCheck(this, FetchHttpClient);\n\n    _this = _super.call(this);\n    _this._fetchFn = fetchFn;\n    return _this;\n  }\n  /** @override. */\n\n\n  _createClass(FetchHttpClient, [{\n    key: \"getClientName\",\n    value: function getClientName() {\n      return 'fetch';\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n      var isInsecureConnection = protocol === 'http';\n      var url = new URL(path, \"\".concat(isInsecureConnection ? 'http' : 'https', \"://\").concat(host));\n      url.port = port;\n      var fetchFn = this._fetchFn || fetch;\n      var fetchPromise = fetchFn(url.toString(), {\n        method: method,\n        headers: headers,\n        body: requestData || undefined\n      }); // The Fetch API does not support passing in a timeout natively, so a\n      // timeout promise is constructed to race against the fetch and preempt the\n      // request, simulating a timeout.\n      //\n      // This timeout behavior differs from Node:\n      // - Fetch uses a single timeout for the entire length of the request.\n      // - Node is more fine-grained and resets the timeout after each stage of\n      //   the request.\n      //\n      // As an example, if the timeout is set to 30s and the connection takes 20s\n      // to be established followed by 20s for the body, Fetch would timeout but\n      // Node would not. The more fine-grained timeout cannot be implemented with\n      // fetch.\n\n      var pendingTimeoutId;\n      var timeoutPromise = new Promise(function (_, reject) {\n        pendingTimeoutId = setTimeout(function () {\n          pendingTimeoutId = null;\n          reject(HttpClient.makeTimeoutError());\n        }, timeout);\n      });\n      return Promise.race([fetchPromise, timeoutPromise]).then(function (res) {\n        return new FetchHttpClientResponse(res);\n      }).finally(function () {\n        if (pendingTimeoutId) {\n          clearTimeout(pendingTimeoutId);\n        }\n      });\n    }\n  }]);\n\n  return FetchHttpClient;\n}(HttpClient);\n\nvar FetchHttpClientResponse = /*#__PURE__*/function (_HttpClientResponse) {\n  _inherits(FetchHttpClientResponse, _HttpClientResponse);\n\n  var _super2 = _createSuper(FetchHttpClientResponse);\n\n  function FetchHttpClientResponse(res) {\n    var _this2;\n\n    _classCallCheck(this, FetchHttpClientResponse);\n\n    _this2 = _super2.call(this, res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));\n    _this2._res = res;\n    return _this2;\n  }\n\n  _createClass(FetchHttpClientResponse, [{\n    key: \"getRawResponse\",\n    value: function getRawResponse() {\n      return this._res;\n    }\n  }, {\n    key: \"toStream\",\n    value: function toStream(streamCompleteCallback) {\n      // Unfortunately `fetch` does not have event handlers for when the stream is\n      // completely read. We therefore invoke the streamCompleteCallback right\n      // away. This callback emits a response event with metadata and completes\n      // metrics, so it's ok to do this without waiting for the stream to be\n      // completely read.\n      streamCompleteCallback(); // Fetch's `body` property is expected to be a readable stream of the body.\n\n      return this._res.body;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._res.json();\n    }\n  }], [{\n    key: \"_transformHeadersToObject\",\n    value: function _transformHeadersToObject(headers) {\n      // Fetch uses a Headers instance so this must be converted to a barebones\n      // JS object to meet the HttpClient interface.\n      var headersObj = {};\n\n      var _iterator = _createForOfIteratorHelper(headers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n\n          if (!Array.isArray(entry) || entry.length != 2) {\n            throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');\n          }\n\n          headersObj[entry[0]] = entry[1];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return headersObj;\n    }\n  }]);\n\n  return FetchHttpClientResponse;\n}(HttpClientResponse);\n\nmodule.exports = {\n  FetchHttpClient: FetchHttpClient,\n  FetchHttpClientResponse: FetchHttpClientResponse\n};","map":{"version":3,"names":["require","HttpClient","HttpClientResponse","FetchHttpClient","fetchFn","_fetchFn","host","port","path","method","headers","requestData","protocol","timeout","isInsecureConnection","url","URL","fetch","fetchPromise","toString","body","undefined","pendingTimeoutId","timeoutPromise","Promise","_","reject","setTimeout","makeTimeoutError","race","then","res","FetchHttpClientResponse","finally","clearTimeout","status","_transformHeadersToObject","_res","streamCompleteCallback","json","headersObj","entry","Array","isArray","length","Error","module","exports"],"sources":["/mnt/c/Users/mbodj/Downloads/treact-ui/node_modules/stripe/lib/net/FetchHttpClient.js"],"sourcesContent":["'use strict';\n\nconst {HttpClient, HttpClientResponse} = require('./HttpClient');\n\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\nclass FetchHttpClient extends HttpClient {\n  constructor(fetchFn) {\n    super();\n    this._fetchFn = fetchFn;\n  }\n\n  /** @override. */\n  getClientName() {\n    return 'fetch';\n  }\n\n  makeRequest(\n    host,\n    port,\n    path,\n    method,\n    headers,\n    requestData,\n    protocol,\n    timeout\n  ) {\n    const isInsecureConnection = protocol === 'http';\n\n    const url = new URL(\n      path,\n      `${isInsecureConnection ? 'http' : 'https'}://${host}`\n    );\n    url.port = port;\n\n    const fetchFn = this._fetchFn || fetch;\n    const fetchPromise = fetchFn(url.toString(), {\n      method,\n      headers,\n      body: requestData || undefined,\n    });\n\n    // The Fetch API does not support passing in a timeout natively, so a\n    // timeout promise is constructed to race against the fetch and preempt the\n    // request, simulating a timeout.\n    //\n    // This timeout behavior differs from Node:\n    // - Fetch uses a single timeout for the entire length of the request.\n    // - Node is more fine-grained and resets the timeout after each stage of\n    //   the request.\n    //\n    // As an example, if the timeout is set to 30s and the connection takes 20s\n    // to be established followed by 20s for the body, Fetch would timeout but\n    // Node would not. The more fine-grained timeout cannot be implemented with\n    // fetch.\n    let pendingTimeoutId;\n    const timeoutPromise = new Promise((_, reject) => {\n      pendingTimeoutId = setTimeout(() => {\n        pendingTimeoutId = null;\n        reject(HttpClient.makeTimeoutError());\n      }, timeout);\n    });\n\n    return Promise.race([fetchPromise, timeoutPromise])\n      .then((res) => {\n        return new FetchHttpClientResponse(res);\n      })\n      .finally(() => {\n        if (pendingTimeoutId) {\n          clearTimeout(pendingTimeoutId);\n        }\n      });\n  }\n}\n\nclass FetchHttpClientResponse extends HttpClientResponse {\n  constructor(res) {\n    super(\n      res.status,\n      FetchHttpClientResponse._transformHeadersToObject(res.headers)\n    );\n    this._res = res;\n  }\n\n  getRawResponse() {\n    return this._res;\n  }\n\n  toStream(streamCompleteCallback) {\n    // Unfortunately `fetch` does not have event handlers for when the stream is\n    // completely read. We therefore invoke the streamCompleteCallback right\n    // away. This callback emits a response event with metadata and completes\n    // metrics, so it's ok to do this without waiting for the stream to be\n    // completely read.\n    streamCompleteCallback();\n\n    // Fetch's `body` property is expected to be a readable stream of the body.\n    return this._res.body;\n  }\n\n  toJSON() {\n    return this._res.json();\n  }\n\n  static _transformHeadersToObject(headers) {\n    // Fetch uses a Headers instance so this must be converted to a barebones\n    // JS object to meet the HttpClient interface.\n    const headersObj = {};\n\n    for (const entry of headers) {\n      if (!Array.isArray(entry) || entry.length != 2) {\n        throw new Error(\n          'Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.'\n        );\n      }\n\n      headersObj[entry[0]] = entry[1];\n    }\n\n    return headersObj;\n  }\n}\n\nmodule.exports = {FetchHttpClient, FetchHttpClientResponse};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}